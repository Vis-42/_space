import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.interpolate import interp1d
from matplotlib.gridspec import GridSpec
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.patches as patches
from matplotlib.patches import Circle, Ellipse
import matplotlib.cm as cm
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# Set up plotting style
plt.style.use('seaborn-v0_8-darkgrid')
plt.rcParams['figure.dpi'] = 100
plt.rcParams['font.size'] = 10

# ========================================
# DEFINE ALL FUNCTIONS
# ========================================
def gaussian_intensity(x, I0, x0, w):
    """Gaussian intensity profile"""
    return I0 * np.exp(-2 * (x - x0)**2 / w**2)

def spot_size_evolution(z, w0, z0, wavelength=632.8e-9):
    """W(z) = W0 * sqrt(1 + ((z-z0)/z_R)^2)"""
    z_R = np.pi * w0**2 / wavelength
    return w0 * np.sqrt(1 + ((z - z0) / z_R)**2)

def calculate_transmission_factor(attenuator_angle):
    """Calculate transmission using Malus's law"""
    theta_rad = np.radians(attenuator_angle)
    return np.cos(theta_rad)**2

# ========================================
# DATA WITH CORRECTED ATTENUATOR VALUES
# ========================================
data_20cm = {
    'offset': [-1.00, -0.90, -0.80, -0.70, -0.60, -0.50, -0.40, -0.30, -0.20, -0.10, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50],
    'reading': [0.048, 0.090, 0.223, 0.789, 1.012, 1.035, 1.223, 1.176, 1.326, 1.629, 1.639, 1.237, 1.025, 0.840, 0.559, 0.403, 0.340, 0.385, 0.166, 0.087, 0.046],
    'attenuator': 85
}

data_50cm = {
    'offset': [-1.00, -0.90, -0.80, -0.70, -0.60, -0.50, -0.40, -0.30, -0.20, -0.10, 0.00, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00],
    'reading': [0.003, 0.012, 0.016, 0.016, 0.084, 0.284, 0.640, 1.112, 1.217, 2.406, 2.563, 2.565, 2.053, 1.317, 0.959, 0.313, 0.099, 0.029, 0.009, 0.008, 0.003],
    'attenuator': 80
}

data_1m = {
    'offset': [-1.00, -0.90, -0.80, -0.70, -0.60, -0.50, -0.40, -0.30, -0.20, -0.10, 0.00, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00],
    'reading': [0.042, 0.122, 0.235, 0.259, 0.655, 1.057, 1.531, 1.627, 2.031, 2.448, 2.570, 2.220, 1.592, 1.089, 1.083, 0.385, 0.198, 0.079, 0.038, 0.019, 0.005],
    'attenuator': 75
}

data_2m = {
    'offset': [-2.00, -1.80, -1.60, -1.40, -1.20, -1.00, -0.80, -0.60, -0.40, -0.20, 0.00, 0.20, 0.40, 0.60, 0.80, 1.00, 1.20, 1.40, 1.60, 1.80, 2.00],
    'reading': [0.019, 0.039, 0.078, 0.159, 0.309, 0.538, 0.935, 1.359, 1.819, 2.213, 2.270, 2.027, 1.552, 1.062, 0.702, 0.280, 0.111, 0.060, 0.021, 0.012, 0.002],
    'attenuator': 65
}

data_5m = {
    'offset': [-4.00, -3.60, -3.20, -2.80, -2.40, -2.00, -1.60, -1.20, -0.80, -0.40, 0.00, 0.40, 0.80, 1.20, 1.60, 2.00, 2.40, 2.80, 3.20, 3.60, 4.00],
    'reading': [0.021, 0.048, 0.092, 0.236, 0.477, 0.800, 1.268, 1.755, 2.180, 2.428, 2.518, 2.446, 2.090, 1.691, 1.109, 0.738, 0.407, 0.165, 0.072, 0.033, 0.015],
    'attenuator': 45
}

data_10m = {
    'offset': [-5.00, -4.50, -4.00, -3.50, -3.00, -2.50, -2.00, -1.50, -1.00, -0.50, 0.00, 0.50, 1.00, 1.50, 2.00, 2.50, 3.00, 3.50, 4.00, 4.50, 5.00],
    'reading': [0.304, 0.472, 0.696, 0.976, 1.295, 1.615, 1.932, 2.222, 2.498, 2.662, 2.749, 2.725, 2.627, 2.401, 2.125, 1.801, 1.499, 1.180, 0.907, 0.657, 0.468],
    'attenuator': 25
}

data_15m = {
    'offset': [-6.00, -5.40, -4.80, -4.20, -3.60, -3.00, -2.40, -1.80, -1.20, -0.60, 0.00, 0.60, 1.20, 1.80, 2.40, 3.00, 3.60, 4.20, 4.80, 5.40, 6.00],
    'reading': [0.333, 0.435, 0.518, 0.626, 0.743, 0.832, 0.928, 1.020, 1.083, 1.108, 1.136, 1.108, 1.069, 1.002, 0.920, 0.820, 0.703, 0.606, 0.499, 0.405, 0.313],
    'attenuator': 0
}

all_data = {
    20: data_20cm, 50: data_50cm, 100: data_1m, 200: data_2m,
    500: data_5m, 1000: data_10m, 1500: data_15m
}

# ========================================
# FIT ALL PROFILES AND EXTRACT PARAMETERS
# ========================================
def fit_gaussian_profile_corrected(data_dict, distance_cm):
    x = np.array(data_dict['offset'])
    y = np.array(data_dict['reading'])
    attenuator = data_dict['attenuator']
    
    T = calculate_transmission_factor(attenuator)
    y_corrected = y / T if T > 0 else y
    y_normalized = y / np.max(y)
    
    # Initial guess
    I0_guess = 1.0
    x0_guess = x[np.argmax(y)]
    half_max = np.max(y_normalized) / 2
    indices = np.where(y_normalized > half_max)[0]
    if len(indices) > 0:
        fwhm = x[indices[-1]] - x[indices[0]]
        w_guess = fwhm / (2 * np.sqrt(np.log(2)))
    else:
        w_guess = 1.0
    
    try:
        popt, pcov = curve_fit(gaussian_intensity, x, y_normalized, p0=[I0_guess, x0_guess, w_guess], maxfev=5000)
        I0_fit, x0_fit, w_fit = popt
        
        # Calculate R-squared
        residuals = y_normalized - gaussian_intensity(x, *popt)
        ss_res = np.sum(residuals**2)
        ss_tot = np.sum((y_normalized - np.mean(y_normalized))**2)
        r_squared = 1 - (ss_res / ss_tot)
        
        # Calculate FWHM
        fwhm_fit = 2 * abs(w_fit) * np.sqrt(np.log(2))
        
        return {
            'distance_cm': distance_cm,
            'spot_size_mm': abs(w_fit),
            'fwhm_mm': fwhm_fit,
            'center_position': x0_fit,
            'max_intensity_corrected': np.max(y_corrected),
            'r_squared': r_squared,
            'x_data': x,
            'y_normalized': y_normalized,
            'y_raw': y,
            'y_corrected': y_corrected,
            'y_fit': gaussian_intensity(x, *popt),
            'transmission_factor': T,
            'attenuator_angle': attenuator
        }
    except:
        return None

# Fit all profiles
results = []
for distance_cm, data in all_data.items():
    result = fit_gaussian_profile_corrected(data, distance_cm)
    if result:
        results.append(result)

# Extract key parameters
distances_cm = np.array([r['distance_cm'] for r in results])
distances_m = distances_cm / 100
spot_sizes_mm = np.array([r['spot_size_mm'] for r in results])
spot_sizes_m = spot_sizes_mm / 1000
wavelength = 632.8e-9  # He-Ne laser

# Fit spot size evolution to get W0 and z0
def spot_size_with_offset(z, w0, z0):
    return spot_size_evolution(z, w0, z0, wavelength)

W0_estimate = spot_sizes_m[0]
popt_evolution, _ = curve_fit(spot_size_with_offset, distances_m, spot_sizes_m, p0=[W0_estimate, 0.0])
W0_fit, z0_fit = popt_evolution

# Calculate derived parameters
z_R_fit = np.pi * W0_fit**2 / wavelength
theta_theoretical = wavelength / (np.pi * W0_fit)
confocal_param = 2 * z_R_fit

# Far-field divergence analysis
far_indices = [-3, -2, -1]
far_distances = distances_m[far_indices]
far_spot_sizes = spot_sizes_m[far_indices]
slope, intercept, r_value, p_value, std_err = stats.linregress(far_distances, far_spot_sizes)
Theta_experimental = slope
M_squared = Theta_experimental / theta_theoretical

# Colors for plotting
colors = plt.cm.rainbow(np.linspace(0, 1, len(results)))

# Print summary of corrections
print("="*80)
print("ATTENUATOR CORRECTIONS APPLIED")
print("="*80)
print(f"{'Distance (cm)':>12} | {'Attenuator (°)':>14} | {'Transmission':>12} | {'Correction Factor':>17}")
print("-"*80)
for r in results:
    print(f"{r['distance_cm']:>12} | {r['attenuator_angle']:>14} | {r['transmission_factor']:>12.4f} | {1/r['transmission_factor']:>17.1f}x")
print("="*80)

# ========================================
# FIGURE 1: MAIN REQUEST - ALL CORRECTED INTENSITY GAUSSIANS OVERLAID
# ========================================
fig1 = plt.figure(figsize=(16, 10))

ax1 = plt.subplot(111)

# Plot all corrected intensity Gaussians on the same plot
for idx, (r, color) in enumerate(zip(results, colors)):
    # Create smooth x values for plotting
    x_smooth = np.linspace(min(r['x_data']) - 1, max(r['x_data']) + 1, 500)
    
    # Calculate the corrected Gaussian intensity
    y_gaussian_corrected = gaussian_intensity(x_smooth, r['max_intensity_corrected'], 
                                             r['center_position'], r['spot_size_mm'])
    
    # Plot the corrected Gaussian curve
    ax1.plot(x_smooth, y_gaussian_corrected, '-', linewidth=2.5, alpha=0.8,
            color=color, label=f"{r['distance_cm']:4d} cm (θ={r['attenuator_angle']:3d}°, T={r['transmission_factor']:.3f})")
    
    # Also plot the actual corrected data points
    ax1.scatter(r['x_data'], r['y_corrected'], s=20, alpha=0.4, color=color, edgecolors='black', linewidth=0.5)

# Formatting
ax1.set_xlabel('Horizontal Position (mm)', fontsize=14)
ax1.set_ylabel('Corrected Intensity (V)', fontsize=14)
ax1.set_title('All Gaussian Beam Intensity Profiles with Attenuator Correction Applied\n(Real Intensities)', 
             fontsize=16, fontweight='bold')
ax1.legend(loc='upper right', fontsize=10, ncol=2, title='Distance (Attenuator, Transmission)')
ax1.grid(True, alpha=0.3)
ax1.set_xlim(-8, 8)
ax1.set_ylim(bottom=0)

# Add annotation explaining the correction
textstr = 'Correction Method:\nI_real = I_measured / T\nwhere T = cos²(θ_attenuator)'
props = dict(boxstyle='round', facecolor='yellow', alpha=0.8)
ax1.text(0.02, 0.98, textstr, transform=ax1.transAxes, fontsize=11,
        verticalalignment='top', bbox=props)

plt.tight_layout()
plt.show()

# ========================================
# FIGURE 2: 3D INTENSITY PLOT (FIXED)
# ========================================
fig2 = plt.figure(figsize=(16, 10))
ax2 = fig2.add_subplot(111, projection='3d')

# Plot 3D intensity distribution with actual surfaces
for idx, (r, color) in enumerate(zip(results, colors)):
    # Create fine mesh for smooth 3D surface
    x_mesh = np.linspace(min(r['x_data']) - 1, max(r['x_data']) + 1, 100)
    
    # Calculate Gaussian intensity
    intensity_mesh = gaussian_intensity(x_mesh, r['max_intensity_corrected'], 
                                       r['center_position'], r['spot_size_mm'])
    
    # Create z coordinate (distance)
    z_mesh = np.full_like(x_mesh, r['distance_cm'])
    
    # Plot the 3D curve
    ax2.plot(x_mesh, z_mesh, intensity_mesh, linewidth=3, color=color, 
            alpha=0.9, label=f'{r["distance_cm"]} cm')
    
    # Add filled surface below the curve
    for i in range(len(x_mesh)-1):
        vertices = [(x_mesh[i], z_mesh[i], 0),
                   (x_mesh[i+1], z_mesh[i], 0),
                   (x_mesh[i+1], z_mesh[i], intensity_mesh[i+1]),
                   (x_mesh[i], z_mesh[i], intensity_mesh[i])]
        from mpl_toolkits.mplot3d.art3d import Poly3DCollection
        poly = Poly3DCollection([vertices], alpha=0.3, facecolor=color, edgecolor='none')
        ax2.add_collection3d(poly)
    
    # Add data points
    ax2.scatter(r['x_data'], np.full_like(r['x_data'], r['distance_cm']), 
               r['y_corrected'], s=30, color=color, alpha=0.6, edgecolors='black', linewidth=0.5)

ax2.set_xlabel('Position (mm)', fontsize=12)
ax2.set_ylabel('Distance (cm)', fontsize=12)
ax2.set_zlabel('Corrected Intensity (V)', fontsize=12)
ax2.set_title('3D Visualization of Gaussian Beam Intensity Evolution', fontsize=14, fontweight='bold')
ax2.view_init(elev=25, azim=-60)
ax2.legend(loc='upper left', fontsize=9)
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# ========================================
# FIGURE 3: NORMALIZED GAUSSIAN FITS OVERLAID
# ========================================
fig3 = plt.figure(figsize=(12, 8))
ax3 = plt.subplot(111)

# Plot normalized Gaussian fits (not raw data)
for idx, (r, color) in enumerate(zip(results, colors)):
    # Create smooth x values
    x_smooth = np.linspace(min(r['x_data']) - 2, max(r['x_data']) + 2, 500)
    
    # Calculate normalized Gaussian fit
    y_gaussian_normalized = gaussian_intensity(x_smooth, 1.0, r['center_position'], r['spot_size_mm'])
    
    # Plot the normalized Gaussian
    ax3.plot(x_smooth, y_gaussian_normalized, '-', linewidth=2, alpha=0.8,
            color=color, label=f"{r['distance_cm']} cm (w={r['spot_size_mm']:.2f} mm)")

ax3.set_xlabel('Horizontal Position (mm)', fontsize=12)
ax3.set_ylabel('Normalized Intensity', fontsize=12)
ax3.set_title('Normalized Gaussian Fits - Beam Width Evolution', fontsize=14, fontweight='bold')
ax3.legend(loc='upper right', fontsize=9)
ax3.grid(True, alpha=0.3)
ax3.set_xlim(-10, 10)
ax3.set_ylim(0, 1.1)

plt.tight_layout()
plt.show()

# ========================================
# FIGURE 4: COMPREHENSIVE ANALYSIS
# ========================================
fig4 = plt.figure(figsize=(20, 12))
gs = GridSpec(3, 3, figure=fig4, hspace=0.3, wspace=0.3)

# Plot 4a: Spot size evolution
ax4a = fig4.add_subplot(gs[0, 0])
z_theory = np.linspace(0, max(distances_m), 1000)
w_theory = spot_size_with_offset(z_theory, W0_fit, z0_fit)

ax4a.scatter(distances_m*100, spot_sizes_mm, s=100, c='blue', edgecolors='darkblue', 
            linewidth=2, label='Experimental', zorder=5)
ax4a.plot(z_theory*100, w_theory*1000, 'r-', linewidth=2, 
         label=f'Theory: W₀={W0_fit*1000:.3f} mm')
ax4a.axvline(x=z0_fit*100, color='green', linestyle='--', alpha=0.5, 
            label=f'Beam Waist ({z0_fit*100:.1f} cm)')
ax4a.axvline(x=(z0_fit + z_R_fit)*100, color='orange', linestyle='--', alpha=0.5, 
            label=f'Rayleigh Range ({z_R_fit*100:.1f} cm)')
ax4a.set_xlabel('Distance (cm)')
ax4a.set_ylabel('Spot Size (mm)')
ax4a.set_title('Spot Size Evolution')
ax4a.legend(fontsize=8)
ax4a.grid(True, alpha=0.3)

# Plot 4b: Linear regression for divergence
ax4b = fig4.add_subplot(gs[0, 1])
ax4b.scatter(distances_m*100, spot_sizes_mm, s=80, c='lightblue', alpha=0.5, label='All Data')
ax4b.scatter(far_distances*100, far_spot_sizes*1000, s=120, c='red', 
            edgecolors='darkred', linewidth=2, label='Far-Field Points', zorder=5)
z_fit = np.linspace(0, max(distances_m)*1.1, 100)
w_fit = slope * z_fit + intercept
ax4b.plot(z_fit*100, w_fit*1000, 'g--', linewidth=2, 
         label=f'Linear Fit: Θ={Theta_experimental*1000:.3f} mrad')
ax4b.set_xlabel('Distance (cm)')
ax4b.set_ylabel('Spot Size (mm)')
ax4b.set_title(f'Divergence Analysis (R²={r_value**2:.4f})')
ax4b.legend()
ax4b.grid(True, alpha=0.3)

# Plot 4c: Peak intensity decay
ax4c = fig4.add_subplot(gs[0, 2])
peak_intensities_corrected = np.array([r['max_intensity_corrected'] for r in results])
I0_theory = peak_intensities_corrected[-1] * (spot_sizes_m[-1]**2)
intensity_theoretical = I0_theory / (spot_sizes_m**2)

ax4c.scatter(distances_cm, peak_intensities_corrected, s=100, c='blue', 
            edgecolors='darkblue', linewidth=2, label='Experimental')
ax4c.plot(distances_cm, intensity_theoretical*1000, 'r--', linewidth=2, label='Theory (∝ 1/w²)')
ax4c.set_xlabel('Distance (cm)')
ax4c.set_ylabel('Peak Intensity (V)')
ax4c.set_title('Intensity Decay')
ax4c.legend()
ax4c.grid(True, alpha=0.3)
ax4c.set_xscale('log')
ax4c.set_yscale('log')

# Plot 4d-4i: Individual fits with residuals
for idx in range(min(6, len(results))):
    ax = fig4.add_subplot(gs[1 + idx//3, idx%3])
    r = results[idx]
    
    ax.scatter(r['x_data'], r['y_normalized'], s=30, alpha=0.6, label='Data')
    ax.plot(r['x_data'], r['y_fit'], 'r-', linewidth=2, label='Fit')
    
    residuals = r['y_normalized'] - r['y_fit']
    ax2 = ax.twinx()
    ax2.bar(r['x_data'], residuals, width=0.05, alpha=0.3, color='gray')
    ax2.set_ylabel('Residuals', fontsize=8)
    ax2.set_ylim(-0.1, 0.1)
    
    ax.set_xlabel('Position (mm)')
    ax.set_ylabel('Normalized Intensity')
    ax.set_title(f"{r['distance_cm']} cm: w={r['spot_size_mm']:.2f} mm, R²={r['r_squared']:.3f}")
    ax.legend(fontsize=8)
    ax.grid(True, alpha=0.3)

plt.suptitle('Comprehensive Gaussian Beam Analysis', fontsize=16, fontweight='bold')
plt.tight_layout()
plt.show()

# ========================================
# FIGURE 5: BEAM QUALITY ANALYSIS
# ========================================
fig5 = plt.figure(figsize=(16, 10))
gs5 = GridSpec(2, 3, figure=fig5, hspace=0.3, wspace=0.3)

# Plot 5a: M² comparison
ax5a = fig5.add_subplot(gs5[0, 0])
divergences = [theta_theoretical*1000, Theta_experimental*1000]
labels = ['Theoretical θ', 'Experimental Θ']
colors_bar = ['blue', 'red']
bars = ax5a.bar(labels, divergences, color=colors_bar, alpha=0.7, 
                edgecolor='black', linewidth=2)
ax5a.text(0.5, max(divergences)*0.8, f'M² = {M_squared:.3f}', 
         horizontalalignment='center', fontsize=14, fontweight='bold',
         bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.8))
ax5a.set_ylabel('Divergence (mrad)')
ax5a.set_title('Beam Quality Factor M²')
ax5a.grid(True, alpha=0.3, axis='y')

# Plot 5b: Conservation check
ax5b = fig5.add_subplot(gs5[0, 1])
intensity_check = peak_intensities_corrected * spot_sizes_mm**2
intensity_check_norm = intensity_check / intensity_check[-1]
ax5b.scatter(distances_cm, intensity_check_norm, s=100, c='blue', 
            edgecolors='darkblue', linewidth=2)
ax5b.axhline(y=1.0, color='red', linestyle='--', alpha=0.5, label='Expected')
ax5b.set_xlabel('Distance (cm)')
ax5b.set_ylabel('I × w² (normalized)')
ax5b.set_title('Power Conservation Check')
ax5b.legend()
ax5b.grid(True, alpha=0.3)
ax5b.set_xscale('log')

# Plot 5c: Comparison at different scales
ax5c = fig5.add_subplot(gs5[0, 2])
for idx, scale in enumerate([1, 0.1, 0.01]):
    ax5c.plot([], [], '-', linewidth=2, label=f'Scale: {scale}')
for idx, (r, color) in enumerate(zip(results[::2], colors[::2])):  # Every other for clarity
    x_smooth = np.linspace(-10, 10, 200)
    y_gaussian = gaussian_intensity(x_smooth, r['max_intensity_corrected'], 
                                   r['center_position'], r['spot_size_mm'])
    ax5c.plot(x_smooth, y_gaussian, '-', linewidth=2, alpha=0.7, color=color)
ax5c.set_xlabel('Position (mm)')
ax5c.set_ylabel('Intensity (V)')
ax5c.set_title('Beam Profiles at Different Distances')
ax5c.grid(True, alpha=0.3)

# Plot 5d: Summary table
ax5d = fig5.add_subplot(gs5[1, :])
ax5d.axis('tight')
ax5d.axis('off')

table_data = [
    ['Parameter', 'Value', 'Unit'],
    ['Beam Waist W₀', f'{W0_fit*1000:.3f}', 'mm'],
    ['Waist Position z₀', f'{z0_fit*100:.1f}', 'cm'],
    ['Rayleigh Range Z_R', f'{z_R_fit*100:.1f}', 'cm'],
    ['Divergence (theory)', f'{theta_theoretical*1000:.3f}', 'mrad'],
    ['Divergence (exp)', f'{Theta_experimental*1000:.3f}', 'mrad'],
    ['M² Factor', f'{M_squared:.3f}', '-'],
]

table = ax5d.table(cellText=table_data, cellLoc='center', loc='center',
                  colWidths=[0.4, 0.3, 0.2])
table.auto_set_font_size(False)
table.set_fontsize(12)
table.scale(1.2, 2)

for i in range(3):
    table[(0, i)].set_facecolor('#4CAF50')
    table[(0, i)].set_text_props(weight='bold', color='white')

plt.suptitle('Beam Quality and Conservation Analysis', fontsize=16, fontweight='bold')
plt.tight_layout()
plt.show()

# Print final summary
print("\n" + "="*80)
print("GAUSSIAN BEAM ANALYSIS COMPLETE")
print("="*80)
print(f"Beam Waist W₀: {W0_fit*1000:.3f} mm")
print(f"Rayleigh Range: {z_R_fit*100:.1f} cm")
print(f"M² Factor: {M_squared:.3f}")
print(f"Divergence - Theory: {theta_theoretical*1000:.3f} mrad, Experimental: {Theta_experimental*1000:.3f} mrad")
print("="*80)
